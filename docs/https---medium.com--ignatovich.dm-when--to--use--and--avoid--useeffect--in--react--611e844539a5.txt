SitemapOpen in appSign upSign inWriteSearchSign upSign inWhen to Use and Avoid useEffect in ReactFrontend Highlights9 min readÂ·Apr 2, 2025--3ListenShareReactâ€™s useEffect hook is one of the most powerful yet often misunderstood parts of the React ecosystem. While it serves as a crucial tool for side effects in React components, many developers overuse it when simpler solutions would suffice. This article explores when useEffect is truly necessary and when alternative approaches would lead to cleaner, more maintainable code.Press enter or click to view image in full sizeUnderstanding useEffectâ€™s PurposeThe primary purpose of useEffect is to synchronize a React component with external systems â€” anything outside of React's state and props. However, many developers reach for useEffect in scenarios where simpler solutions would suffice.Common Misuses of useEffectBefore diving into when to use useEffect, let's examine common situations where it's unnecessarily applied:1. Derived State// âŒ Unnecessary useEffectfunction ProductList({ products }) {  const [filteredProducts, setFilteredProducts] = useState([]);    useEffect(() => {    setFilteredProducts(      products.filter(product => product.inStock)    );  }, [products]);    return (    <ul>      {filteredProducts.map(product => (        <li key={product.id}>{product.name}</li>      ))}    </ul>  );}Better approach: Compute values directly during rendering or use useMemo for expensive calculations:// âœ… Better approachfunction ProductList({ products }) {  // Direct calculation during render  const filteredProducts = products.filter(product => product.inStock);    return (    <ul>      {filteredProducts.map(product => (        <li key={product.id}>{product.name}</li>      ))}    </ul>  );}// For expensive calculationsfunction ProductSearch({ products, searchTerm }) {  const filteredProducts = useMemo(() => {    return products      .filter(product => product.inStock)      .filter(product => product.name.toLowerCase().includes(searchTerm.toLowerCase()))      .sort((a, b) => a.price - b.price);  }, [products, searchTerm]);    return (    <ul>      {filteredProducts.map(product => (        <li key={product.id}>{product.name} - ${product.price}</li>      ))}    </ul>  );}Why this is better:Eliminates unnecessary render cycles â€” The useEffect approach causes two renders: one initial render and another after the effect sets state. The direct computation approach completes in a single render.Reduces state complexity â€” Fewer state variables means less complexity and fewer opportunities for bugs.Guaranteed synchronization â€” Direct calculations are always in sync with their dependencies, whereas useEffect might lag behind due to its execution timing in the React lifecycle.Improves performance â€” Avoiding unnecessary state updates and re-renders leads to better performance, especially in complex component trees.Simplifies debugging â€” With fewer moving parts and states, finding and fixing issues becomes easier.Follows Reactâ€™s declarative paradigm â€” Computing values directly aligns with Reactâ€™s core philosophy of describing what the UI should look like, not how to change it over time.Reduces code complexity â€” The direct approach requires less code and is easier to understand, making your components more maintainable.For truly expensive calculations, useMemo provides the best of both worlds: direct calculation with memoization to prevent unnecessary recalculation.2. React State Updates Based on Props// âŒ function ProfilePage({ userId }) {  const [user, setUser] = useState(null);    useEffect(() => {    setUser({ id: userId, name: `User ${userId}` });  }, [userId]);    return <div>User: {user?.name}</div>;}Better approach: Derive data directly from props:// âœ… Better approachfunction ProfilePage({ userId }) {  // Directly use props for rendering  const userName = `User ${userId}`;    return <div>User: {userName}</div>;}Why this is better:No unnecessary state â€” Since userId is already a prop, it can be used directly to compute userName. No need to store it in useState.Simpler and more efficient â€” Removes extra state and effect, reducing unnecessary re-renders. The component simply recomputes userName from userId on every render.Avoids async/state update issues â€” Because we donâ€™t use useEffect, we avoid potential issues with stale state updates.3. Responding to Events// âŒ Unnecessarily complexfunction SearchComponent() {  const [query, setQuery] = useState('');  const [results, setResults] = useState([]);    useEffect(() => {    if (query) {      searchApi(query).then(setResults);    }  }, [query]); // This runs on every keystroke!    return (    <>      <input         value={query}        onChange={e => setQuery(e.target.value)}      />      <ul>        {results.map(result => (          <li key={result.id}>{result.name}</li>        ))}      </ul>    </>  );}Better approach: Handle events directly with proper debouncing:// âœ… Better approach with debouncingfunction SearchComponent() {  const [query, setQuery] = useState('');  const [results, setResults] = useState([]);    // Use a ref to store the timeout ID  const timeoutRef = useRef(null);    const handleSearch = (value) => {    setQuery(value);        // Clear previous timeout    if (timeoutRef.current) {      clearTimeout(timeoutRef.current);    }        // Set a new timeout to debounce the search    timeoutRef.current = setTimeout(() => {      if (value) {        searchApi(value).then(setResults);      }    }, 300);  };    // Clean up timeout on unmount  useEffect(() => {    return () => {      if (timeoutRef.current) {        clearTimeout(timeoutRef.current);      }    };  }, []);    return (    <>      <input         value={query}        onChange={e => handleSearch(e.target.value)}      />      <ul>        {results.map(result => (          <li key={result.id}>{result.name}</li>        ))}      </ul>    </>  );}4. Data Transformations// âŒ Unnecessary state and effectfunction UserTable({ users }) {  const [formattedUsers, setFormattedUsers] = useState([]);    useEffect(() => {    setFormattedUsers(      users.map(user => ({        ...user,        fullName: `${user.firstName} ${user.lastName}`,        joinDate: new Date(user.joinedAt).toLocaleDateString()      }))    );  }, [users]);    return (    <table>      <thead>        <tr>          <th>Name</th>          <th>Joined</th>        </tr>      </thead>      <tbody>        {formattedUsers.map(user => (          <tr key={user.id}>            <td>{user.fullName}</td>            <td>{user.joinDate}</td>          </tr>        ))}      </tbody>    </table>  );}Better approach: Transform data directly during rendering:// âœ… Better approachfunction UserTable({ users }) {  return (    <table>      <thead>        <tr>          <th>Name</th>          <th>Joined</th>        </tr>      </thead>      <tbody>        {users.map(user => (          <tr key={user.id}>            <td>{`${user.firstName} ${user.lastName}`}</td>            <td>{new Date(user.joinedAt).toLocaleDateString()}</td>          </tr>        ))}      </tbody>    </table>  );}Why this is better:No unnecessary state â€” The transformation (map) happens directly during rendering, without storing the result in state.Simpler and more readable â€” The logic is self-contained within map, making the component easier to understand and maintain.More efficient (avoids extra re-renders) â€” Since thereâ€™s no state update, React renders only once when users changes, instead of rendering twice (first for state update, then for display).No risk of stale state â€” The transformation always reflects the latest users data because it runs during rendering.When would useState be necessary?You should use useState if the transformed data is not purely derived from props, such as:Data fetched asynchronouslyExpensive computations that should be memoizedUser-modifiable state (e.g., filtering or sorting)Traditional useEffect Use Cases and Modern Alternatives1. External System IntegrationsTraditional approach with useEffect:function BrowserLocationTracker() {  const [location, setLocation] = useState(null);  const [error, setError] = useState(null);  useEffect(() => {    if (!navigator.geolocation) {      setError("Geolocation is not supported");      return;    }        const watchId = navigator.geolocation.watchPosition(      position => setLocation({        latitude: position.coords.latitude,        longitude: position.coords.longitude      }),      error => setError(error.message)    );        return () => navigator.geolocation.clearWatch(watchId);  }, []);  if (error) return <div>Error: {error}</div>;  if (!location) return <div>Loading...</div>;    return (    <div>      <p>Latitude: {location.latitude}</p>      <p>Longitude: {location.longitude}</p>    </div>  );}Possible alternative: Custom hooks that encapsulate effects:// A custom hook that abstracts geolocation logicfunction useGeolocation() {  const [location, setLocation] = useState(null);  const [error, setError] = useState(null);  useEffect(() => {    if (!navigator.geolocation) {      setError("Geolocation not supported");      return;    }        const watchId = navigator.geolocation.watchPosition(      position => setLocation({        latitude: position.coords.latitude,        longitude: position.coords.longitude      }),      error => setError(error.message)    );        return () => navigator.geolocation.clearWatch(watchId);  }, []);  return { location, error };}// Component becomes much simplerfunction LocationDisplay() {  const { location, error } = useGeolocation();    if (error) return <div>Error: {error}</div>;  if (!location) return <div>Loading...</div>;    return <div>Lat: {location.latitude}, Long: {location.longitude}</div>;}2. Data Fetching in Client ComponentsTraditional approach with useEffect:function UserProfile({ userId }) {  const [user, setUser] = useState(null);  const [loading, setLoading] = useState(true);  const [error, setError] = useState(null);  useEffect(() => {    let isMounted = true;        const fetchUser = async () => {      try {        setLoading(true);        const response = await fetch(`https://api.example.com/users/${userId}`);                if (!response.ok) {          throw new Error('Failed to fetch user data');        }                const userData = await response.json();                // Only update state if component is still mounted        if (isMounted) {          setUser(userData);          setLoading(false);        }      } catch (err) {        if (isMounted) {          setError(err.message);          setLoading(false);        }      }    };    fetchUser();        // Cleanup function to prevent state updates if component unmounts    return () => {      isMounted = false;    };  }, [userId]);  if (loading) return <div>Loading...</div>;  if (error) return <div>Error: {error}</div>;  if (!user) return null;  return (    <div>      <h1>{user.name}</h1>      <p>Email: {user.email}</p>    </div>  );}Alternative: React Query/SWR:import { useQuery } from '@tanstack/react-query';function UserProfile({ userId }) {  const {     data: user,     isLoading,     error   } = useQuery({    queryKey: ['user', userId],    queryFn: () => fetch(`/api/users/${userId}`)      .then(r => {        if (!r.ok) throw new Error('Failed to fetch user');        return r.json();      })  });    if (isLoading) return <div>Loading...</div>;  if (error) return <div>Error: {error.message}</div>;    return (    <div>      <h1>{user.name}</h1>      <p>Email: {user.email}</p>    </div>  );}Alternative: React Server Components:// In Next.js or similar frameworks with React Server Componentsasync function UserProfile({ userId }) {  const response = await fetch(`https://api.example.com/users/${userId}`);    if (!response.ok) {    // Handle errors appropriately in Server Components    return <div>Error loading user</div>;  }    const user = await response.json();    return (    <div>      <h1>{user.name}</h1>      <p>Email: {user.email}</p>    </div>  );}3. Synchronizing with External StateTraditional approach with useEffect:function ThemeSync({ systemTheme }) {  const [currentTheme, setCurrentTheme] = useState(systemTheme);    useEffect(() => {    setCurrentTheme(systemTheme);    ThemeService.applyTheme(systemTheme);  }, [systemTheme]);    return (    <div className={`app ${currentTheme}`}>      <p>Current theme: {currentTheme}</p>    </div>  );}Alternative: React Context + useReducer:// Create a theme contextconst ThemeContext = createContext();// Theme provider that manages system theme changesfunction ThemeProvider({ children }) {  const [theme, dispatch] = useReducer(themeReducer, 'light');    // Still needs useEffect for system theme changes  useEffect(() => {    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');        // Set initial theme    dispatch({       type: mediaQuery.matches ? 'DARK' : 'LIGHT'     });        // Listen for changes    const handler = (e) => {      dispatch({         type: e.matches ? 'DARK' : 'LIGHT'       });    };        mediaQuery.addEventListener('change', handler);    return () => mediaQuery.removeEventListener('change', handler);  }, []);    return (    <ThemeContext.Provider value={{ theme, dispatch }}>      {children}    </ThemeContext.Provider>  );}// Components can use theme without useEffectfunction ThemedButton() {  const { theme } = useContext(ThemeContext);  return <button className={theme}>Click me</button>;}Yes, it still uses useEffect, butâ€¦1. Centralized theme management â€” The ThemeProvider manages theme updates in one place, making it easy to keep the entire app in sync.Any component can access the theme via useContext, avoiding prop drilling.2. More efficient state updates â€” Instead of re-running useEffect in multiple components, theme changes are handled once in ThemeProvider. Components like ThemedButton donâ€™t need their own useEffectâ€”they just read the theme from context.3. Decouples state from UI â€” The theme logic is separated from UI components. If theme logic changes (e.g., storing user preferences in local storage), you only need to update ThemeProvider, not every component.4. Better scalability â€” If more components need theme access, they can just useContext(ThemeContext), avoiding unnecessary prop drilling.4. Cleanup OperationsTraditional approach with useEffect:function Timer() {  const [seconds, setSeconds] = useState(0);    useEffect(() => {    const intervalId = setInterval(() => {      setSeconds(s => s + 1);    }, 1000);        return () => clearInterval(intervalId);  }, []);    return <div>Timer: {seconds} seconds</div>;}Alternative: Custom hooks + AbortController for fetch:// Custom hook for intervalsfunction useInterval(callback, delay) {  const savedCallback = useRef(callback);  // Remember the latest callback  useEffect(() => {    savedCallback.current = callback;  }, [callback]);  // Set up the interval  useEffect(() => {    if (delay !== null) {      const id = setInterval(() => savedCallback.current(), delay);      return () => clearInterval(id);    }  }, [delay]);}// Using the custom hookfunction Timer() {  const [seconds, setSeconds] = useState(0);    useInterval(() => {    setSeconds(s => s + 1);  }, 1000);    return <div>Timer: {seconds} seconds</div>;}// For fetch operationsfunction DataFetcher() {  const [data, setData] = useState(null);    const handleFetch = async () => {    const controller = new AbortController();    const signal = controller.signal;        try {      const response = await fetch('/api/data', { signal });      const result = await response.json();      setData(result);    } catch (err) {      if (err.name !== 'AbortError') {        console.error(err);      }    }        // Cleanup function    return () => controller.abort();  };    // Still needs useEffect for component lifecycle  useEffect(() => {    const cleanup = handleFetch();    return cleanup;  }, []);    return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;}The Reality: Some useEffect is Still Necessary ðŸ’¡While we can minimize useEffect usage, some scenarios genuinely require a side-effect mechanism. Even modern libraries like React Query use useEffect under the hood. The goal isn't complete elimination but judicious usage.Press enter or click to view image in full sizeStrategies to Minimize useEffectâœ… Move effects to the boundary of your applicationKeep most components pure and push side effects to the edgesâœ… Abstract effects into custom hooksHide implementation details and create reusable effect patternsâœ… Use specialized libraries for common patternsData fetching: React Query, SWRForm handling: React Hook Form, FormikAnimation: Framer Motion, React Springâœ… Use modern React patternsServer Components for data fetchingContext for shared stateReducers for complex state logicBest Practices When Using useEffectWhen you do need to use useEffect, follow these guidelines:âœ… Be specific with dependenciesInclude all values from component scope used by the effectUse the ESLint exhaustive-deps ruleâœ… Separate concernsEach effect should do one thingBreak complex effects into multiple simpler onesâœ… Always clean upReturn cleanup functions to prevent memory leaksHandle race conditions in async operationsâœ… Avoid object/function dependencies when possibleThey can cause unnecessary re-rendersUse useCallback/useMemo or move them outside the componentConclusionWhile useEffect remains a fundamental part of React, many use cases can be handled with more direct approaches or modern alternatives. By understanding when useEffect is truly necessary and when it can be avoided, you'll write cleaner, more efficient React code.The React team continues to evolve the framework to reduce the need for effects, but side effects will always be a part of UI programming. The key is learning to manage them effectively, pushing them to the edges of your application, and keeping your component logic as pure as possible.Remember â€” useEffect is a hack in React to step out from React flow. ðŸ¥‡The golden rule is: Try to solve your problem without useEffect first, and only reach for it when dealing with true side effects that interact with systems outside of React's control.ReactReactjsUseeffectFront End DevelopmentReact HookWritten by Frontend Highlights4.3K followersÂ·8 followingThis page is about simple frontend things which can be useful in real work Support us on https://buymeacoffee.com/guestdm or https://ko-fi.com/dm110416Responses (3)See all responsesHelpStatusAboutCareersPressBlogPrivacyRulesTermsText to speech